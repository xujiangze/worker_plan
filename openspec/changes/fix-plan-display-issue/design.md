## Context
前端无法展示计划列表,后端 API 响应有数据但前端没有显示。这是一个典型的数据格式不匹配问题。

### 问题分析
1. **后端数据格式**: Go 的 `*time.Time` 类型在 JSON 序列化时默认使用 RFC3339 格式,但可能因为指针类型导致序列化问题
2. **前端期望格式**: 前端 TypeScript 类型定义期望 `due_date` 是可选的字符串类型 (ISO 8601 格式)
3. **响应拦截器**: 前端响应拦截器提取 `response.data.data`,需要确保后端返回的数据结构正确

### 约束条件
- 必须保持向后兼容性
- 不能破坏现有的 API 契约
- 需要支持可选的截止日期字段

## Goals / Non-Goals

### Goals
- 确保后端返回的时间字段使用 ISO 8601 格式字符串
- 确保前端能正确解析和显示时间数据
- 添加适当的错误处理和日志记录
- 保持 API 响应结构的一致性

### Non-Goals
- 修改 API 响应的整体结构
- 改变前端的时间显示格式(保持现有的本地化格式)
- 添加新的 API 端点

## Decisions

### Decision 1: 使用自定义 JSON 序列化器
**选择**: 为 `DueDate` 字段实现自定义的 `MarshalJSON` 和 `UnmarshalJSON` 方法

**理由**:
- Go 的默认时间序列化可能不符合前端期望
- 自定义序列化器可以确保格式一致性
- 不需要修改数据库模型

**替代方案**:
- 使用 `gorm` 的自定义类型 - 过于复杂
- 在控制器层手动转换 - 增加代码复杂度
- 修改前端解析逻辑 - 前端逻辑已经正确,问题在后端

### Decision 2: 保持指针类型
**选择**: 继续使用 `*time.Time` 指针类型表示可选字段

**理由**:
- 数据库层面支持 NULL 值
- 前端类型定义中 `due_date` 是可选的
- 符合 Go 的惯用法

### Decision 3: 添加调试日志
**选择**: 在 store 的 fetchPlans 方法中添加 console.log

**理由**:
- 便于快速定位问题
- 不影响生产环境性能(可以后续移除)
- 帮助理解数据流

## Risks / Trade-offs

### Risks
1. **时间格式兼容性**: 如果其他客户端依赖不同的时间格式,可能需要调整
   - **缓解**: 使用标准的 ISO 8601 格式,这是广泛接受的标准

2. **性能影响**: 自定义序列化器可能有轻微性能开销
   - **缓解**: 序列化操作不是性能瓶颈,影响可忽略

3. **测试覆盖**: 需要确保所有时间相关的场景都被测试
   - **缓解**: 添加单元测试和集成测试

### Trade-offs
- **简单性 vs 灵活性**: 选择简单直接的解决方案,而不是过度设计
- **开发速度 vs 完美性**: 优先解决当前问题,后续可以优化

## Migration Plan

### 步骤
1. 修改 `internal/model/plan.go`,添加自定义 JSON 方法
2. 添加单元测试验证序列化格式
3. 在前端 store 添加临时调试日志
4. 本地测试验证修复效果
5. 移除调试日志(可选)

### 回滚
如果出现问题,可以:
1. 回退到默认的 Go 时间序列化
2. 在前端添加时间格式转换逻辑
3. 使用 Git 回滚代码更改

## Open Questions
1. 是否需要支持其他时间格式?(当前不需要)
2. 是否需要添加时区支持?(当前使用本地时间)
3. 是否需要为其他时间字段也添加自定义序列化器?(CreatedAt/UpdatedAt 使用默认格式即可)
